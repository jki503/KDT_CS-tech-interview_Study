# HTTP

> Application layer에 존재하는 프로토콜로 클라이언트와 서버가 웹상에서 데이터를 주고 받을 수 있도록 해준다.

## 특징

</br>

- stateless(무상태)
  - 서버가 클라이언트의 상태를 보존 해주지 않는다.
  - 서버와 클라이언트를 독립적으로 개발 가능하게 해주고, 확장성의 용이하다.
  - 즉 항상 같은 클라이언트와 서버가 연결이 유지될 필요는 없다는 것.
  - 손님이 n명이 있고, 요리사가 k명이 있다고 하면
  - 특정 요리사 B가 손님 A의 주문을 받을 필요가 없다는 뜻.

</br>

- 비 연결성
  - 요청과 응답시에만 유지하고 연결을 종료 한다. - 한정된 서버 자원을 효율적으로 사용 가능
  - 그렇기 때문에 TCP/IP의 handshake RTT가 추가되는 단점...

</br>

## 버전

</br>

### HTTP 1.1

- HTTP가 갖는 특성에 따라 갖는 단점을 보완 하기 위해 나온 버전
- `Keep-alive 옵션`을 적용하여 기존 연결에 대해서 3hand-shake 생략 가능
- 또한 `파이프라이닝 기법`으로 이전 요청이 완료되기 이전에 요청이 들어온다면 연결을 끊지 않아 `latency를 낮춰줌`

</br>

- 단점

- `HOLB(head of line blocking 문제)` : 먼저 받은 요청이 처리가 끝나지 않으면 그 뒤의 요청이 빨리 처리 할 수 있어도 대기해야하는 문제
- `무거운 Header 구조` : http 1.1은 많은 메타 정보들이 저장 되어 있음
- 즉, 다수의 http 요청이 발생하게 될 경우 매 요청마다 중복되는 헤더값을 전송하게 되어 전송값보다 헤더가 더 큰 경우도 있음.

</br>

### HTTP 2.0

</br>

|                 http versiion                 |
| :-------------------------------------------: |
| ![http version img](../res/http-versions.png) |

- `멀티플렉싱` : HTTP 1.1과 가장 큰 차이점은 동시에 여러 개의 메시지를 주고 받는 것이 가능
- `Stream Prioritization` : HTML 문서 안에 여러 파일이 존재 할 때, 수신이 늦어지는 경우 브라우저의 랜더링이 늦어지는 문제 발생하기 때문에 http 2.0에서는 리소스간 의존 관계를 설정하여 문제 해결.
- `Server Push` : 서버는 클라이언트에게 요청하지도 않은 리소스를 보냄. http 1.1에서는 클라이언트는 요청한 html 문서를 수신한 후 html 문서를 해석하여 필요한 리소스를 재요청
- but, http 2.0에서는 Server push 기법을 통해서 클라이언트가 요청하지 않은 리소스를 push 해주는 방법으로 클라이언트의 요청을 최소화 하여 성능 향상.
- `Header Compression` : header 정보를 압축하기 위해 `HPACK 압축 방식` 사용
- header에 중복값이 존재 할 경우 Static/Dyanamic Header Table 개념을 사용하여 중복 Header 검출 하여 중복된 header는 index만 보냄.

</br>

## HTTP 1.1 / HTTP 2.0 여전한 단점

> 결론적으로 두 개의 버전 모두 성능을 개선해왔지만  
> Transport layer의 TCP/IP 기반으로 데이터를 전송하기 때문에  
> hand-shake의 RTT로 인한 지연을 해결하기는 어렵다.
