# HTTP 1.1/2.0

</br>

## HTTP 1.1

- HTTP가 갖는 특성에 따라 갖는 단점을 보완 하기 위해 나온 버전
- `Keep-alive 옵션`을 적용하여 기존 연결에 대해서 3hand-shake 생략 가능
- 또한 `파이프라이닝 기법`으로 이전 요청이 완료되기 이전에 요청이 들어온다면 연결을 끊지 않아 `latency를 낮춰줌`
- 캐시 기능 추가

</br>

### 파이프 라이닝

|                      파이프 라이닝                       |
| :------------------------------------------------------: |
| ![파이프 라이닝](./res/../../res/http1.1_pipelining.png) |

</br>

- 하나의 커넥션에서 한 번에 순차적인 여러 요청을 보내고 기다리는 방식
- HOL 문제 발생, 대부분의 브라우저가 막고 있는 방식
- 병렬 커넥션을 사용해 다수의 커넥션에서 1개의 요청을 보내는 방식으로 속도 개선

</br>

- 단점

- `HOLB(head of line blocking 문제)` : 먼저 받은 요청이 처리가 끝나지 않으면 그 뒤의 요청이 빨리 처리 할 수 있어도 대기해야하는 문제
- `무거운 Header 구조` : http 1.1은 많은 메타 정보들이 저장 되어 있음
- 즉, 다수의 http 요청이 발생하게 될 경우 매 요청마다 중복되는 헤더값을 전송하게 되어 전송값보다 헤더가 더 큰 경우도 있음.

</br>

## HTTP 2.0

</br>

|                 http versiion                 |
| :-------------------------------------------: |
| ![http version img](../res/http-versions.png) |

- `멀티플렉싱` : HTTP 1.1과 가장 큰 차이점은 동시에 여러 개의 메시지를 주고 받는 것이 가능
- `Stream Prioritization` : HTML 문서 안에 여러 파일이 존재 할 때, 수신이 늦어지는 경우 브라우저의 랜더링이 늦어지는 문제 발생하기 때문에 http 2.0에서는 리소스간 의존 관계를 설정하여 문제 해결.
- `Server Push` : 서버는 클라이언트에게 요청하지도 않은 리소스를 보냄. http 1.1에서는 클라이언트는 요청한 html 문서를 수신한 후 html 문서를 해석하여 필요한 리소스를 재요청
- but, http 2.0에서는 Server push 기법을 통해서 클라이언트가 요청하지 않은 리소스를 push 해주는 방법으로 클라이언트의 요청을 최소화 하여 성능 향상.
- `Header Compression` : header 정보를 압축하기 위해 `HPACK 압축 방식` 사용
- header에 중복값이 존재 할 경우 Static/Dyanamic Header Table 개념을 사용하여 중복 Header 검출 하여 중복된 header는 index만 보냄.

</br>

## HTTP 1.1 / HTTP 2.0 여전한 단점

> 결론적으로 두 개의 버전 모두 성능을 개선해왔지만  
> Transport layer의 TCP/IP 기반으로 데이터를 전송하기 때문에  
> hand-shake의 RTT로 인한 지연을 해결하기는 어렵다.
