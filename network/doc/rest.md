---
Title : Rest와 Restful
Category
---

## REST

> REST API는 정보들이 주고 받아지는데 있어서  
> 개발자들 사이에 널리 쓰이는 일종의 형식이다.
>
> 프로토콜과 같은 규약이 아닌 `가이드라인`이기 때문에,
> 이러한 권장 사항의 구현 여부는 개발자에게 달려있다.

</br>

## REST 구성

</br>

- 자원
  - 자원을 구별할 수 있는 URI 사용
  - 명사로 구성
  - classes/3/students/12: 3반의 12번 학생을 가리키는 URI
  - classes/3/students/12update(x)
  - 대부분에 웹은 뒤에 붙는 `/`를 허용하나 URI는 이를 다른 것으로 인식
- 행위
  - GET : 데이터 조회
  - POST : 데이터 삽입
  - DELETE : 데이터 삭제
  - PUT : Entity 단위로 데이터 수정
  - PATCH : Entity 일부 데이터 수정
- 표현
  - client가 자원에 대한 조작 요청하면 server는 이에 대한 응답
  - Json, xml (주로 Json 선호)

</br>

### 내생각

</br>

- 실제 개발
  - 실제 개발에서 Restful하게 명세를 나누기가 어려웠다.
    - Restful api인지 조금 난해
    - 동사를 안쓰기가 조금 어색한 상황
    - 가이드라인이기때문에 어느정도 융통성 있게 uri 명세를 진행했다.

### HTTP POST와 PUT

</br>

- 특정 API의 경우 POST와 PUT을 합쳐서 쓴 상황이 있었다.
  - 특정 row의 존재 유무를 확인한 후 지우고 삭제해야하는 경우였는데,
  - 이 경우 존재하던 존재하지 않는 상황에서도 결과를 보장해야해서 PUT으로 해결했다.
  - PUT의 멱등성 보장을 살림.

</br>

> HTTP 메소드 하나로만 처리 가능하지만  
> 행위에 대한 명확성과  
> HTTP 바디가 불필요한 요청의 경우 낭비를 방지

</br>

### Json 선호 이유

> xml보다 가벼워 대옹량에서 xml보다 렌더링 속도에서 우위
> json은 데이터로도, 객체 및 배열로도 표현할 수 있음.

</br>

## RESTful

</br>

### 1. Client - Server 구조

> 서버와 클라이언트의 책임이 분리되어, 의존성이 적어야 한다.

</br>

### 2. Stateless

> 서버는 들어오는 요청만 처리하고, 작업을 위한 상태 정보는 따로 저장 X  
> 불필요한 정보 관리 X -> 구현 단순화

</br>

### 3. Cacheable

</br>

- Last - Modifed

> 최초의 API에 응답을 받을 때  
> 데이터베이스의 마지막 수정된 시간을 `response`로 받은 후  
> 동일한 요청을 다시 보낼 때 이 정보를 `request header`에 담아 보낸다.  
> api 핸들러가 이 시간을 체크하여 DB가 이후 수정된 기록 없다면  
> cache 되었던 데이터를 다시 보낸다.  
> -> DB에서 마지막 변경되 시간 관리 할 때 유리  
> -> 비교적 간단한 테이터 유리 (Join은 각 테이블 모두 조회 해야한다.)

</br>

- Etag

> Last-Modifed와 다르게 Hash 값 사용  
> `response`에 `Etag`를 추가하여 응답  
> 클라이언트는 동일 요청을 다시 보낼 때 Etag를 request header에 추가  
> response 데이터의 MD5 - Hash 사용

</br>

> Http Cache를 사용할 때  
> 변경되지 않은 경우 `304 상태 코드` 리턴  
> 변경된 경우 `200으로 리턴`

</br>

### 4. Uniform interface

> URI로 지정한 리소스에 대한 조작을 통일되고 한정적 인터페이스로 수행

</br>

- resource는 uri로 식별해야 한다.
- main자원에 대한 행위는 Http Method로 표현 해야 한다.
- `self-descriptive messages` : 메시지는 스스로 메시지를 설명해야한다.
  - 응답 코드
  - 응답 데이터
  - 응답 경로
  - 응답의 해석을 위한 명세서 포함
- `hypermeida as the engine of application state` : 애플리케이션 상태는 Hyperlink를 이용해 전이 되어야 한다.

</br>

#### Uniform Inerface 필요한 이유

</br>

- 서버와 클라이언트가 독립적으로 진화
  - 서버의 기능이 변경 되어도 클라이언트 업데이트 필요 X
- 서버나 클라이언트가 변경되어도 메시지는 언제나 해석 가능
- 링크가 동적으로 변경 되어 상태를 미리 결정하지 않아, 다음 전이 될 상태가 결정 된다.

</br>

## REST 장점

- HTTP 표준 프로토콜 따르는 플랫폼에서 사용 가능
- 메시지의 의도를 명확하게 파악 가능
- 서버와 클라이언트의 독립적 진화 가능

</br>

## REST 단점

- HTTP 메소드가 제한적, 또는 기능에 따라 모호한 성격을 띌 수 있음
- REST는 표준 규약이 아니기에 개발자의 역량으로 결정
- Overfetching : 불필요한 정보까지 보내어 네트워크 낭비
- Underfetching : 각 정보를 가져올 수 있는 API를 여러번 요청..
- 상황에 따라 많은 endpoint가 생길 수 있음 <-> graphQL과 대조적

</br>

## SOAP

</br>

> 응용 계층에 있는 프로토콜을 전송계층의 프로토콜로 사용할 수 있게 해준다.  
> 프로토콜 즉 규약으로, REST보다 많은 규약과 표준으로 오버헤드 높음  
> XML로 표현 된다 -> 단점  
> 보안, 트랙잭션, ACID 등 데이터 무결성을 위할 경우 적합  
> UDDI라는 전역 서비스 장소 통해, 정의된 XML 등록,  
> 사용자는 UDDI에서 필요한 서비스를 요청하여 결과 받음

</br>

|             |                         SOAP                         |                       REST                        |
| :---------: | :--------------------------------------------------: | :-----------------------------------------------: |
|    유형     |                       프로토콜                       |                  아키텍처 스타일                  |
|    기능     |            기능 위주 : 구조화된 정보 전송            |     데이터 위주 : 데이터를 위해 리소스에 접근     |
| 데이터 포맷 |                      XML만 사용                      |     text, HTML, XML, JSON 등 다양한 포맷 허용     |
|    보안     |                   WS-Security, SSL                   |                    SSL, HTTPS                     |
|   대역폭    |       상대적으로 더 많은 리소스와 대역폭 필요        |                     적게 필요                     |
| 데이터 캐시 |                        캐시 X                        | 캐시 사용 가능 -> 각 endpoint 별로 캐시가 구성 됨 |
|  페이로드   | 모든 메시지가 보내기 전에 알려져야함으로 랜더링 느림 |               미리 알릴 필요가 없다               |
|    ACID     |          자체적 기준으로 데이터 손상 줄여줌          |                  준수관련 내용 X                  |

</br>
